package excav

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"

	"github.com/sn3d/excav/pkg/dir"
	"gopkg.in/yaml.v2"
)

// Configuration is loaded from ~/.config/excav/config.yaml file
type Configuration struct {
	// path to workspace where are repositories cloned. Default is {currentdir}/.excav
	WorkspaceDir string `yaml:"workspace"`

	// path to directory where current state is stored. Default is {currentdir}/.excav/state
	//StateDir string `yaml:"state"`

	// The GitLab host (e.g. https://gitlab.com)
	GitLabHost string `yaml:"gitlab"`

	// Private access token which is generated by GitLab.
	// see https://gitlab.com/profile/personal_access_tokens
	GitLabToken string `yaml:"gitlab_token"`

	// The GitHub host (e.g. https://github.com)
	GitHubHost string `yaml:"github"`

	// The GitHub API host (e.g. https://api.github.com). Usually API is available in
	// different hostname starting with api.*
	GitHubApiHost string `yaml:"github_api"`

	// User for GitHub
	GitHubUser string `yaml:"github_user"`

	// Personal access token which is generated by GitHub
	// see https://github.com/settings/tokens
	GitHubToken string `yaml:"github_token"`
}

// Default loading of configuration. The order of loading is:
//
// - first we try load config.yaml in current working directory
// - then try load config.yaml from `{USER_HOME}/.config/excav/config.yaml'
// - (not implemented) load from env. variables (TODO)
func LoadConfiguration() (*Configuration, error) {

	// load from current dir first
	userHome, _ := os.UserHomeDir()
	currentDir, _ := os.Getwd()
	config, err := ReadYamlConfig(filepath.Join(currentDir, "config.yaml"))

	// if it fails, we try to load from .config dir in home folder
	if err != nil {
		config, err = ReadYamlConfig(filepath.Join(userHome, ".config", "excav", "config.yaml"))

		// if it fails, probably file doesn't exists and we will
		// use env. variables. Unfortunately this is not yet implemented
		if err != nil {
			// TODO: load config from env. variables
			fmt.Println("cannot load configuration from {USER_HOME}/.config/excav/config.yaml")
			os.Exit(1)
		}
	}

	// validate and set default values
	if config.WorkspaceDir == "" {
		config.WorkspaceDir = filepath.Join(currentDir, ".excav")
	}

	//if config.StateDir == "" {
	//	config.StateDir = filepath.Join(currentDir, ".excav")
	//}

	return config, nil
}

// create configuration used by tests. This configuration
// relly on tetmporary workspace;
func TestConfiguration() (*Configuration, error) {
	testCfg := &Configuration{
		WorkspaceDir: string(dir.Temp()),
	}

	return testCfg, nil
}

func ReadYamlConfig(configFile string) (*Configuration, error) {
	// read and decode config.yaml file
	data, err := ioutil.ReadFile(configFile)
	if err != nil {
		return nil, fmt.Errorf("cannot read file %s", configFile)
	}

	// decode YAML
	var config Configuration
	err = yaml.Unmarshal(data, &config)
	if err != nil {
		return nil, err
	}

	return &config, nil
}

// SaveToYaml save the config into given file. If file exists, it will
// be overridden. Ensure the parent directories exists, otherwise saving fail.
func (cfg *Configuration) SaveToYaml(file string) error {
	data, err := yaml.Marshal(cfg)
	if err != nil {
		return err
	}

	err = ioutil.WriteFile(file, data, 0664)
	return err
}

func (cfg *Configuration) String() string {
	return fmt.Sprintf("Workspace: %s, GitLabHost: %s", cfg.WorkspaceDir, cfg.GitLabHost)
}

func getEnvStr(key string, def string) string {
	val, present := os.LookupEnv(key)
	if !present {
		return def
	}
	return val
}

func (cfg *Configuration) GetProviderType() string {
	if cfg.GitHubToken != "" {
		return "github"
	} else if cfg.GitLabToken != "" {
		return "gitlab"
	}
	// TODO: better handling of this case
	return ""
}

func (cfg *Configuration) GetProviderHost() string {
	if cfg.GitHubToken != "" {
		return cfg.GitHubHost
	} else if cfg.GitLabToken != "" {
		return cfg.GitLabHost
	}
	// TODO: better handling of this case
	return ""
}

func (cfg *Configuration) GetProviderApiHost() string {
	if cfg.GitHubToken != "" {
		return cfg.GitHubApiHost
	} else if cfg.GitLabToken != "" {
		return cfg.GitLabHost
	}
	// TODO: better handling of this case
	return ""
}

func (cfg *Configuration) GetProviderUser() string {
	if cfg.GitHubUser != "" {
		return cfg.GitHubUser
	}
	return ""
}

func (cfg *Configuration) GetProviderToken() string {
	if cfg.GitHubToken != "" {
		return cfg.GitHubToken
	} else if cfg.GitLabToken != "" {
		return cfg.GitLabToken
	}
	// TODO: better handling of this case
	return ""
}

// function set defaul bulk. That means
// exav will work with this bulk by default.
//
// The bulk ID is written into {WORKSPACE}/current file.
func (cfg *Configuration) SetCurrentBulk(bulkID string) error {
	var err error

	path := filepath.Join(cfg.WorkspaceDir, "current")
	if bulkID == "" {
		// delete the 'current'
		err = os.Remove(path)
	} else {
		// write the ID into 'current'
		err = ioutil.WriteFile(path, []byte(bulkID), 0644)
	}

	return err
}

// function returns you ID of current bulk
// The current bulk is written in ${WORKSPACE}/currert file
func (cfg *Configuration) GetCurrentBulk() string {
	path := filepath.Join(cfg.WorkspaceDir, "current")
	bulkID, err := ioutil.ReadFile(path)
	if err != nil {
		return ""
	}

	return string(bulkID)
}

// function returns you directory of current bulk
func (cfg *Configuration) GetCurrentBulkDir() dir.Directory {
	bulkID := cfg.GetCurrentBulk()
	return dir.New(cfg.WorkspaceDir, bulkID)
}
